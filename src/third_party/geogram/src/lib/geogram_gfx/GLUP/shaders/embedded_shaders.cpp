/*
 * This file was automatically generated, do not edit.
 */

#include <geogram_gfx/GLUP/shaders/embedded_shaders.h>
#include <geogram_gfx/basic/common.h>
#include <geogram_gfx/basic/GLSL.h>

namespace GLUP {
   void register_embedded_shaders() {
     GEO::GLSL::register_GLSL_include_file("GLUP/constants.h",
        "const int GLUP_CLIP_STANDARD         = 0; \n"
        "const int GLUP_CLIP_WHOLE_CELLS      = 1; \n"
        "const int GLUP_CLIP_STRADDLING_CELLS = 2; \n"
        "const int GLUP_CLIP_SLICE_CELLS      = 3; \n"
        " \n"
        "const int GLUP_TEXTURE_1D = 1; \n"
        "const int GLUP_TEXTURE_2D = 2; \n"
        "const int GLUP_TEXTURE_3D = 3; \n"
        " \n"
        "const int GLUP_TEXTURE_REPLACE  = 0; \n"
        "const int GLUP_TEXTURE_MODULATE = 1; \n"
        "const int GLUP_TEXTURE_ADD      = 2; \n"
        " \n"
        "const int GLUP_PICK_PRIMITIVE   = 1; \n"
        "const int GLUP_PICK_CONSTANT    = 2; \n"
        " \n"
        "const int GLUP_POINTS     =0; \n"
        "const int GLUP_LINES      =1; \n"
        "const int GLUP_TRIANGLES  =2; \n"
        "const int GLUP_QUADS      =3; \n"
        "const int GLUP_TETRAHEDRA =4; \n"
        "const int GLUP_HEXAHEDRA  =5; \n"
        "const int GLUP_PRISMS     =6; \n"
        "const int GLUP_PYRAMIDS   =7; \n"
        "const int GLUP_CONNECTORS =8; \n"
        " \n"
        "const int GLUP_LIGHTING           =0; \n"
        "const int GLUP_VERTEX_COLORS      =1; \n"
        "const int GLUP_TEXTURING          =2; \n"
        "const int GLUP_DRAW_MESH          =3; \n"
        "const int GLUP_CLIPPING           =4; \n"
        "const int GLUP_INDIRECT_TEXTURING =5; \n"
        "const int GLUP_PICKING            =6; \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUP/stdglup.h",
        "//import <GLUP/constants.h> \n"
        " \n"
        "#ifdef GL_ES \n"
        "int glup_mod(in int x, in int y) { \n"
        "    return x - (x/y)*y; \n"
        "} \n"
        "#else \n"
        "int glup_mod(in int x, in int y) { \n"
        "    return x % y; \n"
        "} \n"
        "#endif \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUP/fragment_shader_utils.h",
        " \n"
        "#ifdef GL_ES \n"
        "vec4 glup_texture(in sampler2D samp, in vec2 uv) { \n"
        "    return texture2D(samp, uv); \n"
        "} \n"
        "#else \n"
        "vec4 glup_texture(in sampler2D samp, in vec2 uv) { \n"
        "    return texture(samp, uv); \n"
        "} \n"
        "#endif \n"
        " \n"
        "#ifdef GL_ES \n"
        "// converts an integer into an ivec4. The components of \n"
        "// the ivec4 contains the 4 bytes of the integer. \n"
        "ivec4 int_to_ivec4(in int x) { \n"
        "    // TODO: we still have unsigned-signed conversion \n"
        "    // problems. Picking id in state should be unsigned. \n"
        "    if(x < 0) { \n"
        "        return ivec4(255,255,255,255); \n"
        "    } \n"
        "    int w = x; \n"
        "    int R = glup_mod(w, 256); \n"
        "    w /= 256; \n"
        "    int G = glup_mod(w, 256); \n"
        "    w /= 256; \n"
        "    int B = glup_mod(w, 256); \n"
        "    w /= 256; \n"
        "    int A = glup_mod(w, 256); \n"
        "    return ivec4(R,G,B,A); \n"
        "} \n"
        "#else \n"
        "ivec4 int_to_ivec4(in int x) { \n"
        "    return ivec4( \n"
        "         x        & 255, \n"
        "        (x >>  8) & 255, \n"
        "        (x >> 16) & 255, \n"
        "        (x >> 24) & 255 \n"
        "    ); \n"
        "} \n"
        "#endif \n"
        " \n"
        "// adds two 32 bits integers V1 and V2 represented \n"
        "// as ivec4. \n"
        "ivec4 ivec4_add(in ivec4 V1, in ivec4 V2) { \n"
        "    int R = V1.r + V2.r; \n"
        "    int carry = R/256; \n"
        "    R -= carry*256; \n"
        "    int G = V1.g + V2.g + carry; \n"
        "    carry = G/256; \n"
        "    G -= carry*256; \n"
        "    int B = V1.b + V2.b + carry; \n"
        "    carry = B/256; \n"
        "    B -= carry*256; \n"
        "    int A = V1.a + V2.a + carry; \n"
        "    return ivec4(R,G,B,A); \n"
        "} \n"
        " \n"
        "// converts a 32 bit represented by an ivec4 \n"
        "// into a color. \n"
        "vec4 ivec4_to_vec4(in ivec4 V) { \n"
        "    return vec4( \n"
        "        float(V.r)/255.0, \n"
        "        float(V.g)/255.0, \n"
        "        float(V.b)/255.0, \n"
        "        float(V.a)/255.0 \n"
        "    ); \n"
        "} \n"
        " \n"
        "// converts a 32 bit represented by an int \n"
        "// into a color. \n"
        "highp vec4 int_to_vec4(in int x) { \n"
        "    return ivec4_to_vec4(int_to_ivec4(x)); \n"
        "} \n"
        " \n"
        "float min3(in float x, in float y, in float z) { \n"
        "    return min(min(x,y),z); \n"
        "} \n"
        " \n"
        "float min4(in float x, in float y, in float z, in float w) { \n"
        "    return min(min(x,y),min(z,w)); \n"
        "} \n"
        " \n"
        "float edge_factor1(in float bary) { \n"
        "    float d = fwidth(bary); \n"
        "    float a = smoothstep(0.0, d*GLUP.mesh_width, bary); \n"
        "    return a; \n"
        "} \n"
        " \n"
        "float edge_factor3(in vec3 bary) { \n"
        "    vec3 d = fwidth(bary); \n"
        "    vec3 a = smoothstep( \n"
        "        vec3(0.0, 0.0, 0.0), d*GLUP.mesh_width, bary \n"
        "    ); \n"
        "    return min3(a.x, a.y ,a.z); \n"
        "} \n"
        " \n"
        "float edge_factor4(in vec4 bary) { \n"
        "    vec4 d = fwidth(bary); \n"
        "    vec4 a = smoothstep( \n"
        "        vec4(0.0, 0.0, 0.0, 0.0), d*GLUP.mesh_width, bary \n"
        "    ); \n"
        "    return min4(a.x, a.y, a.z, a.w); \n"
        "} \n"
        " \n"
        "vec4 glup_picking(in highp int primitive_id) { \n"
        "    vec4 result; \n"
        "    if(GLUP.picking_mode == GLUP_PICK_PRIMITIVE) { \n"
        "        ivec4 A4 = int_to_ivec4(primitive_id); \n"
        "        // TODO: this one will not work if GPU has lowprec fshaders \n"
        "        ivec4 B4 = int_to_ivec4(GLUP.base_picking_id); \n"
        "        result = ivec4_to_vec4(ivec4_add(A4,B4)); \n"
        "    } else { \n"
        "        result = int_to_vec4(GLUP.picking_id); \n"
        "    } \n"
        "    return result; \n"
        "} \n"
        " \n"
        "vec4 glup_texturing(in vec4 color, in vec4 tex_coord) { \n"
        "    vec4 result = color; \n"
        "    vec4 tex_color; \n"
        "    if(GLUP.texture_type == GLUP_TEXTURE_1D) { \n"
        "        tex_color = glup_texture( \n"
        "            texture1Dsampler, tex_coord.xy \n"
        "        ); \n"
        "    } \n"
        "#ifdef GLUP_NO_TEXTURE_3D \n"
        "    else { \n"
        "        tex_color = glup_texture( \n"
        "            texture2Dsampler, tex_coord.xy \n"
        "        ); \n"
        "    } \n"
        "#else \n"
        "    else if(GLUP.texture_type == GLUP_TEXTURE_2D) { \n"
        "        tex_color = texture( \n"
        "            texture2Dsampler, tex_coord.xy \n"
        "        ); \n"
        "    } else if(GLUP.texture_type == GLUP_TEXTURE_3D) { \n"
        "        tex_color = texture( \n"
        "            texture3Dsampler, tex_coord.xyz \n"
        "        ); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_INDIRECT_TEXTURING)) { \n"
        "        tex_color = GLUP.texture_matrix * tex_color; \n"
        "        tex_color = texture(texture1Dsampler, tex_color.xy); \n"
        "    } \n"
        "#endif \n"
        "    if(GLUP.texture_mode == GLUP_TEXTURE_REPLACE) { \n"
        "        result = tex_color; \n"
        "    } else if(GLUP.texture_mode==GLUP_TEXTURE_MODULATE) { \n"
        "        result *= tex_color; \n"
        "    } else { \n"
        "        result += tex_color; \n"
        "    } \n"
        "    return result; \n"
        "} \n"
        " \n"
        "vec4 glup_lighting(in vec4 color, in vec3 normal) { \n"
        "    vec4 result = color; \n"
        "    float diff = dot(normal,GLUP.light_vector); \n"
        "    float spec = dot(normal,GLUP.light_half_vector); \n"
        "    spec = pow(spec,30.0); \n"
        "    if(diff > 0.0) { \n"
        "        vec3 vspec = spec*vec3(1.0,1.0,1.0); \n"
        "        result = (diff*result) + vec4(vspec,1.0); \n"
        "        result.rgb += vec3(0.2, 0.2, 0.2); \n"
        "    } else { \n"
        "        result = vec4(0.2, 0.2, 0.2, 1.0); \n"
        "    } \n"
        "    return result; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/fragment_shader_utils.h",
        "//import <GLUP/fragment_shader_utils.h> \n"
        " \n"
        "float cell_edge_factor(in vec2 bary) { \n"
        "    return edge_factor1(1.0-(1.0 - bary.x)*(1.0 - bary.y)); \n"
        "} \n"
        " \n"
        "float edge_factor(in vec4 bary) { \n"
        "    if(glup_primitive == GLUP_TRIANGLES) { \n"
        "        return edge_factor3(bary.xyz); \n"
        "    } else if(glup_primitive == GLUP_QUADS) { \n"
        "        return edge_factor4(bary); \n"
        "    } else if(glup_primitive == GLUP_TETRAHEDRA) { \n"
        "        float e1 = cell_edge_factor(bary.xy); \n"
        "        float e2 = cell_edge_factor(bary.xz); \n"
        "        float e3 = cell_edge_factor(bary.xw); \n"
        "        float e4 = cell_edge_factor(bary.yz); \n"
        "        float e5 = cell_edge_factor(bary.yw); \n"
        "        float e6 = cell_edge_factor(bary.zw); \n"
        "        return min3(min(e1,e2),min(e3,e4),min(e5,e6)); \n"
        "    } else if(glup_primitive == GLUP_HEXAHEDRA) { \n"
        "        vec3 u = bary.xyz; \n"
        "        vec3 U = vec3(1.0, 1.0, 1.0) - u; \n"
        "        float e1 = cell_edge_factor(vec2(u.x,u.y)); \n"
        "        float e2 = cell_edge_factor(vec2(u.x,u.z)); \n"
        "        float e3 = cell_edge_factor(vec2(u.x,U.y)); \n"
        "        float e4 = cell_edge_factor(vec2(u.x,U.z)); \n"
        "        float e5 = cell_edge_factor(vec2(U.x,u.y)); \n"
        "        float e6 = cell_edge_factor(vec2(U.x,u.z)); \n"
        "        float e7 = cell_edge_factor(vec2(U.x,U.y)); \n"
        "        float e8 = cell_edge_factor(vec2(U.x,U.z)); \n"
        "        float e9  = cell_edge_factor(vec2(u.y,u.z)); \n"
        "        float e10 = cell_edge_factor(vec2(u.y,U.z)); \n"
        "        float e11 = cell_edge_factor(vec2(U.y,u.z)); \n"
        "        float e12 = cell_edge_factor(vec2(U.y,U.z)); \n"
        "        float r1 = min4(e1,e2,e3,e4); \n"
        "        float r2 = min4(e5,e6,e7,e8); \n"
        "        float r3 = min4(e9,e10,e11,e12); \n"
        "        return min3(r1,r2,r3); \n"
        "    } else if(glup_primitive == GLUP_PRISMS) { \n"
        "        vec4 bary2 = vec4(bary.x, bary.y, bary.z, 1.0 - bary.w); \n"
        "        float e1 = cell_edge_factor(bary.xw); \n"
        "        float e2 = cell_edge_factor(bary.yw); \n"
        "        float e3 = cell_edge_factor(bary.zw); \n"
        "        float e4 = cell_edge_factor(bary2.xw); \n"
        "        float e5 = cell_edge_factor(bary2.yw); \n"
        "        float e6 = cell_edge_factor(bary2.zw); \n"
        "        float e7 = cell_edge_factor(bary.xy); \n"
        "        float e8 = cell_edge_factor(bary.yz); \n"
        "        float e9 = cell_edge_factor(bary.zx); \n"
        "        return min(min3(e7,e8,e9), \n"
        "                   min3(min(e1,e2), \n"
        "                        min(e3,e4),min(e5,e6)) \n"
        "               ); \n"
        "    } \n"
        "    return 1.0; \n"
        "} \n"
        " \n"
        "vec4 glup_draw_mesh(in vec4 color, in vec4 mesh_tex_coord) { \n"
        "#ifdef GLUP_NO_MESH_TEX_COORDS \n"
        "    return color; \n"
        "#else \n"
        "    return mix( \n"
        "        GLUP.mesh_color, color, edge_factor(mesh_tex_coord) \n"
        "    ); \n"
        "#endif \n"
        "} \n"
        " \n"
        "vec4 glup_shading( \n"
        "    in vec4 color, \n"
        "    in vec4 tex_coord, \n"
        "    in vec3 normal, \n"
        "    in highp int primitive_id, \n"
        "    in vec4 mesh_tex_coord \n"
        ") { \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "        return glup_picking(primitive_id); \n"
        "    } \n"
        "    vec4 result; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        result = color; \n"
        "    } else { \n"
        "        result = gl_FrontFacing ? GLUP.front_color : GLUP.back_color; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        result = glup_texturing(result, tex_coord); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        result = glup_lighting(result, normal); \n"
        "    } \n"
        "    if( \n"
        "        glupIsEnabled(GLUP_DRAW_MESH) && ( \n"
        "            (glup_primitive_dimension == 2) || \n"
        "            !glupIsEnabled(GLUP_CLIPPING) || \n"
        "            GLUP.clipping_mode != GLUP_CLIP_SLICE_CELLS \n"
        "        ) \n"
        "    ) { \n"
        "        result = glup_draw_mesh(result, mesh_tex_coord); \n"
        "    } \n"
        "    return result; \n"
        "} \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/vertex_shader_state.h",
        "struct VSUniformState { \n"
        "    mat3  normal_matrix; \n"
        "    mat4 modelviewprojection_matrix; \n"
        "    mat4 modelview_matrix; \n"
        "    mat4 texture_matrix; \n"
        "    vec4  world_clip_plane; \n"
        "    float point_size; \n"
        "}; \n"
        " \n"
        "uniform VSUniformState GLUP_VS; \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/fragment_shader_state.h",
        "struct UniformState { \n"
        "    bool vertex_colors_enabled; \n"
        " \n"
        "    vec4  front_color; \n"
        "    vec4  back_color; \n"
        " \n"
        "    bool  draw_mesh_enabled; \n"
        "    vec4  mesh_color; \n"
        "    float mesh_width; \n"
        " \n"
        "    bool  lighting_enabled; \n"
        "    vec3  light_vector; \n"
        "    vec3  light_half_vector; \n"
        " \n"
        "    bool texturing_enabled; \n"
        "    bool indirect_texturing_enabled; \n"
        "    int  texture_mode; \n"
        "    int  texture_type; \n"
        " \n"
        "    float cells_shrink; \n"
        " \n"
        "    bool  picking_enabled; \n"
        "    int   picking_mode; \n"
        "    int   picking_id; \n"
        "    int   base_picking_id; \n"
        " \n"
        "    bool  clipping_enabled; \n"
        "    int   clipping_mode; \n"
        "    vec4  clip_plane; \n"
        " \n"
        "}; \n"
        " \n"
        "uniform UniformState GLUP; \n"
        "uniform sampler2D texture1Dsampler; \n"
        "uniform sampler2D texture2Dsampler; \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/points_and_lines_vertex_shader.h",
        "//import <GLUP/current_profile/vertex_shader_preamble.h> \n"
        "//import <GLUPES/vertex_shader_state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        " \n"
        "#ifdef GL_ES \n"
        "   attribute vec4 vertex_in; \n"
        "   attribute vec4 color_in; \n"
        "   attribute vec4 tex_coord_in; \n"
        "   attribute highp float vertex_id_in; \n"
        "   varying vec4 color; \n"
        "   varying vec4 tex_coord; \n"
        "   varying float clip_dist; \n"
        "   varying highp float primitive_id; \n"
        "#else \n"
        "   in vec4 vertex_in; \n"
        "   in vec4 color_in; \n"
        "   in vec4 tex_coord_in; \n"
        "   in highp float vertex_id_in; \n"
        "   out vec4 color; \n"
        "   out vec4 tex_coord; \n"
        "   out float clip_dist; \n"
        "   flat out highp int primitive_id; \n"
        "#endif \n"
        " \n"
        "void main() { \n"
        "    if(glupIsEnabled(GLUP_CLIPPING)) { \n"
        "        clip_dist = dot(vertex_in, GLUP_VS.world_clip_plane); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "#ifdef GL_ES \n"
        "        primitive_id = float(int(vertex_id_in + 0.5)) + 0.5; \n"
        "#else \n"
        "        primitive_id = int(vertex_id_in + 0.5); \n"
        "#endif \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        color = color_in; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        tex_coord = GLUP_VS.texture_matrix * tex_coord_in; \n"
        "    } \n"
        "    if(glup_primitive == GLUP_POINTS) { \n"
        "        gl_PointSize = GLUP_VS.point_size; \n"
        "    } \n"
        "    gl_Position = GLUP_VS.modelviewprojection_matrix * vertex_in; \n"
        "} \n"
        " \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/points_fragment_shader.h",
        "//import <GLUP/current_profile/fragment_shader_preamble.h> \n"
        "//import <GLUPES/fragment_shader_state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUPES/fragment_shader_utils.h> \n"
        " \n"
        "#ifdef GL_ES \n"
        "   varying vec4 color; \n"
        "   varying vec4 tex_coord; \n"
        "   varying float clip_dist; \n"
        "   varying highp float primitive_id; \n"
        "#define glup_FragColor gl_FragColor \n"
        "#else \n"
        "   in vec4 color; \n"
        "   in vec4 tex_coord; \n"
        "   in float clip_dist; \n"
        "   flat in highp int primitive_id; \n"
        "   out vec4 glup_FragColor; \n"
        "#endif \n"
        " \n"
        " \n"
        "void main() { \n"
        " \n"
        "    if(glupIsEnabled(GLUP_CLIPPING) && (clip_dist < 0.0)) { \n"
        "        discard; \n"
        "    } \n"
        " \n"
        "    vec2 V = 2.0*(gl_PointCoord - vec2(0.5, 0.5)); \n"
        "    float one_minus_r2 = 1.0 - dot(V,V); \n"
        "    if(one_minus_r2 < 0.0) { \n"
        "        discard; \n"
        "    } \n"
        " \n"
        "    vec3 N = vec3(V.x, -V.y, sqrt(one_minus_r2)); \n"
        "#ifdef GL_EXT_frag_depth \n"
        "    gl_FragDepthEXT = gl_FragCoord.z - 0.001 * N.z; \n"
        "#endif \n"
        " \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "        glup_FragColor = glup_picking(int(primitive_id)); \n"
        "        return; \n"
        "    } \n"
        " \n"
        "    vec4 result; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        result = color; \n"
        "    } else { \n"
        "        result = GLUP.front_color; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        result = glup_texturing(result, tex_coord); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        result = glup_lighting(result, N); \n"
        "    } \n"
        "    glup_FragColor = result; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/lines_fragment_shader.h",
        "//import <GLUP/current_profile/fragment_shader_preamble.h> \n"
        "//import <GLUPES/fragment_shader_state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUPES/fragment_shader_utils.h> \n"
        " \n"
        "#ifdef GL_ES \n"
        "   varying vec4 color; \n"
        "   varying vec4 tex_coord; \n"
        "   varying float clip_dist; \n"
        "   varying highp float primitive_id; \n"
        "#define glup_FragColor gl_FragColor \n"
        "#else \n"
        "   in vec4 color; \n"
        "   in vec4 tex_coord; \n"
        "   in float clip_dist; \n"
        "   flat in highp int primitive_id; \n"
        "   out vec4 glup_FragColor; \n"
        "#endif \n"
        " \n"
        " \n"
        "void main() { \n"
        " \n"
        "    if(glupIsEnabled(GLUP_CLIPPING) && (clip_dist < 0.0)) { \n"
        "        discard; \n"
        "    } \n"
        " \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "        glup_FragColor = glup_picking(int(primitive_id)); \n"
        "        return; \n"
        "    } \n"
        " \n"
        "    vec4 result; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        result = color; \n"
        "    } else { \n"
        "        result = GLUP.front_color; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        result = glup_texturing(result, tex_coord); \n"
        "    } \n"
        "    glup_FragColor = result; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/vertex_shader.h",
        "//import <GLUP/current_profile/vertex_shader_preamble.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUPES/vertex_shader_state.h> \n"
        " \n"
        "#ifdef GL_ES \n"
        "   attribute vec4 vertex_in; \n"
        "   attribute vec4 color_in; \n"
        "   attribute vec4 tex_coord_in; \n"
        "   attribute float vertex_id_in; \n"
        "   varying vec3 vertex_clip_space; \n"
        "   varying float clip_dist; \n"
        "   varying vec4 color; \n"
        "   varying vec4 tex_coord; \n"
        "   varying vec4 mesh_tex_coord; \n"
        "   varying highp float primitive_id; \n"
        "#else \n"
        "   in vec4 vertex_in; \n"
        "   in vec4 color_in; \n"
        "   in vec4 tex_coord_in; \n"
        "   in highp float vertex_id_in; \n"
        "   out vec3 vertex_clip_space; \n"
        "   out float clip_dist; \n"
        "   out vec4 color; \n"
        "   out vec4 tex_coord; \n"
        "   out vec4 mesh_tex_coord; \n"
        "   flat out highp int primitive_id; \n"
        "#endif \n"
        " \n"
        " \n"
        "void main() { \n"
        " \n"
        "    if(glupIsEnabled(GLUP_CLIPPING)) { \n"
        "        clip_dist = dot( \n"
        "            vertex_in, GLUP_VS.world_clip_plane \n"
        "        ); \n"
        "    } \n"
        " \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "#ifdef GL_ES \n"
        "        // Note: we need to add 0.5, else there are some precision \n"
        "        // issues, and the integer mod() operation creates random \n"
        "        // values... \n"
        "        primitive_id = float( \n"
        "            int(vertex_id_in+0.5)/glup_primitive_nb_vertices \n"
        "        )+0.5; \n"
        "#else \n"
        "        primitive_id = int(vertex_id_in + 0.5)/glup_primitive_nb_vertices; \n"
        "#endif \n"
        "    } \n"
        " \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        vertex_clip_space = (GLUP_VS.modelview_matrix * vertex_in).xyz; \n"
        "    } \n"
        " \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        color = color_in; \n"
        "    } \n"
        " \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        tex_coord = GLUP_VS.texture_matrix * tex_coord_in; \n"
        "    } \n"
        " \n"
        "    if(glupIsEnabled(GLUP_DRAW_MESH)) { \n"
        "        mesh_tex_coord = get_mesh_tex_coord(int(vertex_id_in + 0.5)); \n"
        "    } \n"
        " \n"
        "    gl_Position = GLUP_VS.modelviewprojection_matrix * vertex_in; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPES/fragment_shader.h",
        "//import <GLUP/current_profile/fragment_shader_preamble.h> \n"
        "//import <GLUPES/fragment_shader_state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUPES/fragment_shader_utils.h> \n"
        " \n"
        "#ifdef GL_ES \n"
        "   varying vec3 vertex_clip_space; \n"
        "   varying float clip_dist; \n"
        "   varying vec4 color; \n"
        "   varying vec4 tex_coord; \n"
        "   varying vec4 mesh_tex_coord; \n"
        "   varying highp float primitive_id; \n"
        "#define glup_FragColor gl_FragColor \n"
        "#else \n"
        "   in vec3 vertex_clip_space; \n"
        "   in float clip_dist; \n"
        "   in vec4 color; \n"
        "   in vec4 tex_coord; \n"
        "   in vec4 mesh_tex_coord; \n"
        "   flat in highp int primitive_id; \n"
        "   out vec4 glup_FragColor; \n"
        "#endif \n"
        " \n"
        " \n"
        "void main() { \n"
        " \n"
        "    if(glupIsEnabled(GLUP_CLIPPING)) { \n"
        "        if(glup_primitive_dimension == 2) { \n"
        "            if(clip_dist < 0.0) { \n"
        "                discard; \n"
        "            } \n"
        "        } else if(glup_primitive_dimension == 3) { \n"
        "            if( \n"
        "                clip_dist < 0.0 && \n"
        "                GLUP.clipping_mode == GLUP_CLIP_STANDARD \n"
        "            ) { \n"
        "                discard; \n"
        "            } \n"
        "        } \n"
        "    } \n"
        " \n"
        "    vec3 N; \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        vec3 U = dFdx(vertex_clip_space); \n"
        "        vec3 V = dFdy(vertex_clip_space); \n"
        "        N = normalize(cross(U,V)); \n"
        "    } \n"
        " \n"
        "    glup_FragColor = glup_shading( \n"
        "        color, tex_coord, N, int(primitive_id), mesh_tex_coord \n"
        "    ); \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/state.h",
        "layout(shared) \n"
        "uniform GLUPStateBlock { \n"
        " \n"
        "    bool vertex_colors_enabled; \n"
        " \n"
        "    vec4  front_color; \n"
        "    vec4  back_color; \n"
        " \n"
        "    bool draw_mesh_enabled; \n"
        "    vec4  mesh_color; \n"
        "    float mesh_width; \n"
        " \n"
        "    bool lighting_enabled; \n"
        "    vec3 light_vector; \n"
        "    vec3 light_half_vector; \n"
        " \n"
        "    bool texturing_enabled; \n"
        "    bool indirect_texturing_enabled; \n"
        "    int  texture_mode; \n"
        "    int  texture_type; \n"
        " \n"
        "    float cells_shrink; \n"
        " \n"
        "    bool picking_enabled; \n"
        "    int   picking_mode; \n"
        "    int   picking_id; \n"
        "    int   base_picking_id; \n"
        " \n"
        "    bool clipping_enabled; \n"
        "    int   clipping_mode; \n"
        "    vec4  clip_plane; \n"
        "    vec4  world_clip_plane; \n"
        " \n"
        "    mat4 modelviewprojection_matrix; \n"
        "    mat4 modelview_matrix; \n"
        "    mat4 projection_matrix; \n"
        "    mat3 normal_matrix; \n"
        "    mat4 texture_matrix; \n"
        " \n"
        "    float point_size; \n"
        "} GLUP; \n"
        " \n"
        "// Note: the 1D colormap is stored in a 2D texture, because \n"
        "// 1D textures are not supported by all OpenGL implementations \n"
        "uniform sampler2D texture1Dsampler; \n"
        "uniform sampler2D texture2Dsampler; \n"
        "uniform sampler3D texture3Dsampler; \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/points_and_lines_vertex_shader.h",
        "//import <GLUP/current_profile/vertex_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        " \n"
        "in vec4 vertex_in; \n"
        "in vec4 color_in; \n"
        "in vec4 tex_coord_in; \n"
        " \n"
        "out VertexData { \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "} VertexOut; \n"
        " \n"
        "void main() { \n"
        "    if(glupIsEnabled(GLUP_CLIPPING)) { \n"
        "        gl_ClipDistance[0] = dot( \n"
        "            vertex_in, GLUP.world_clip_plane \n"
        "        ); \n"
        "    } else { \n"
        "        gl_ClipDistance[0] = 0.0; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        VertexOut.color = color_in; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        if(glupIsEnabled(GLUP_INDIRECT_TEXTURING)) { \n"
        "            VertexOut.tex_coord = tex_coord_in; \n"
        "        } else { \n"
        "            VertexOut.tex_coord = GLUP.texture_matrix * tex_coord_in; \n"
        "        } \n"
        "    } \n"
        "    gl_PointSize = GLUP.point_size; \n"
        "    gl_Position = GLUP.modelviewprojection_matrix*vertex_in; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/points_fragment_shader.h",
        "//import <GLUP/current_profile/fragment_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUP/fragment_shader_utils.h> \n"
        " \n"
        "out vec4 glup_FragColor ; \n"
        "in float gl_ClipDistance[]; \n"
        " \n"
        "#ifdef GL_ARB_conservative_depth \n"
        "layout (depth_less) out float gl_FragDepth; \n"
        "#endif \n"
        " \n"
        "in VertexData { \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "} FragmentIn; \n"
        " \n"
        "void main() { \n"
        " \n"
        "#ifdef GL_ES \n"
        "    if(glupIsEnabled(GLUP_CLIPPING) && (gl_ClipDistance[0] < 0.0)) { \n"
        "        discard; \n"
        "    } \n"
        "#endif \n"
        " \n"
        "    vec2 V = 2.0*(gl_PointCoord - vec2(0.5, 0.5)); \n"
        "    float one_minus_r2 = 1.0 - dot(V,V); \n"
        "    if(one_minus_r2 < 0.0) { \n"
        "        discard; \n"
        "    } \n"
        " \n"
        "    vec3 N = vec3(V.x, -V.y, sqrt(one_minus_r2)); \n"
        "    gl_FragDepth = gl_FragCoord.z - 0.001 * N.z; \n"
        " \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "        glup_FragColor = glup_picking(gl_PrimitiveID); \n"
        "        return; \n"
        "    } \n"
        " \n"
        "    vec4 result; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        result = FragmentIn.color; \n"
        "    } else { \n"
        "        result = GLUP.front_color; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        result = glup_texturing(result, FragmentIn.tex_coord); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        result = glup_lighting(result, N); \n"
        "    } \n"
        "    glup_FragColor = result; \n"
        "} \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/lines_fragment_shader.h",
        "//import <GLUP/current_profile/fragment_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUP/fragment_shader_utils.h> \n"
        " \n"
        "out vec4 glup_FragColor ; \n"
        "in float gl_ClipDistance[]; \n"
        " \n"
        "in VertexData { \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "} FragmentIn; \n"
        " \n"
        "void main() { \n"
        " \n"
        "#ifdef GL_ES \n"
        "    if(glupIsEnabled(GLUP_CLIPPING) && (gl_ClipDistance[0] < 0.0)) { \n"
        "        discard; \n"
        "    } \n"
        "#endif \n"
        " \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "        glup_FragColor = glup_picking(gl_PrimitiveID); \n"
        "        return; \n"
        "    } \n"
        " \n"
        "    vec4 result; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        result = FragmentIn.color; \n"
        "    } else { \n"
        "        result = GLUP.front_color; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        result = glup_texturing(result, FragmentIn.tex_coord); \n"
        "    } \n"
        " \n"
        "    glup_FragColor = result; \n"
        "} \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/vertex_shader.h",
        "//import <GLUP/current_profile/vertex_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        " \n"
        "in vec4 vertex_in; \n"
        "in vec4 color_in; \n"
        "in vec4 tex_coord_in; \n"
        " \n"
        "out VertexData { \n"
        "    vec4 vertex_clip_space; \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "} VertexOut; \n"
        " \n"
        "void main(void) { \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        VertexOut.color = color_in; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        if(glupIsEnabled(GLUP_INDIRECT_TEXTURING)) { \n"
        "            VertexOut.tex_coord = tex_coord_in; \n"
        "        } else { \n"
        "            VertexOut.tex_coord = \n"
        "                GLUP.texture_matrix * tex_coord_in; \n"
        "        } \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_CLIPPING) || glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        VertexOut.vertex_clip_space = GLUP.modelview_matrix * vertex_in; \n"
        "    } \n"
        "    gl_Position = GLUP.modelviewprojection_matrix * vertex_in; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/gather_vertex_shader.h",
        "//import <GLUP/current_profile/vertex_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        " \n"
        "in vec4 vertex_in[glup_nb_vertices_per_GL_v]; \n"
        "in vec4 color_in[glup_nb_vertices_per_GL_v]; \n"
        "in vec4 tex_coord_in[glup_nb_vertices_per_GL_v]; \n"
        " \n"
        "out GVertexData { \n"
        "    vec4 other_vertex_screen_space[glup_nb_vertices_per_GL_v-1]; \n"
        "    vec4 vertex_clip_space[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 color[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 tex_coord[glup_nb_vertices_per_GL_v]; \n"
        "} VertexOut; \n"
        " \n"
        " \n"
        "void main(void) { \n"
        "    for(int i=0; i<glup_nb_vertices_per_GL_v; ++i) { \n"
        "        if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "            VertexOut.color[i] = color_in[i]; \n"
        "        } \n"
        "        if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "            if(glupIsEnabled(GLUP_INDIRECT_TEXTURING)) { \n"
        "                VertexOut.tex_coord[i] = tex_coord_in[i]; \n"
        "            } else { \n"
        "                VertexOut.tex_coord[i] = GLUP.texture_matrix * tex_coord_in[i]; \n"
        "            } \n"
        "        } \n"
        "        if(glupIsEnabled(GLUP_CLIPPING) || glupIsEnabled(GLUP_LIGHTING)) { \n"
        "            VertexOut.vertex_clip_space[i] = \n"
        "                GLUP.modelview_matrix * vertex_in[i]; \n"
        "        } \n"
        "    } \n"
        " \n"
        "    for(int i=1; i<glup_nb_vertices_per_GL_v; ++i) { \n"
        "        VertexOut.other_vertex_screen_space[i-1] = \n"
        "            GLUP.modelviewprojection_matrix * vertex_in[i]; \n"
        "    } \n"
        " \n"
        "    gl_Position = GLUP.modelviewprojection_matrix * vertex_in[0]; \n"
        "} \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/fragment_shader.h",
        "//import <GLUP/current_profile/fragment_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        "//import <GLUP/fragment_shader_utils.h> \n"
        " \n"
        "out vec4 glup_FragColor ; \n"
        "in float gl_ClipDistance[]; \n"
        " \n"
        "in VertexData { \n"
        "    vec4 vertex_clip_space; \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "    vec4 mesh_tex_coord; \n"
        "} FragmentIn; \n"
        " \n"
        " \n"
        "bool is_triangle(in vec4 mesh_tex_coord) { \n"
        "    if( \n"
        "        !glupIsEnabled(GLUP_CLIPPING) || \n"
        "        GLUP.clipping_mode != GLUP_CLIP_SLICE_CELLS \n"
        "    ) { \n"
        "        switch(glup_primitive) { \n"
        "        case GLUP_TRIANGLES: \n"
        "            return true; \n"
        "        case GLUP_QUADS: \n"
        "            return false; \n"
        "        case GLUP_TETRAHEDRA: \n"
        "            return true; \n"
        "        case GLUP_HEXAHEDRA: \n"
        "            return false; \n"
        "        } \n"
        "    } \n"
        "    return ( \n"
        "        (mesh_tex_coord.x + \n"
        "         mesh_tex_coord.y + \n"
        "         mesh_tex_coord.z + \n"
        "         mesh_tex_coord.w) < 1.5 \n"
        "    ); \n"
        "} \n"
        " \n"
        "float edge_factor(in vec4 mesh_tex_coord) { \n"
        "    if(is_triangle(mesh_tex_coord)) { \n"
        "        return edge_factor3(mesh_tex_coord.xyz); \n"
        "    } else { \n"
        "        return edge_factor4(mesh_tex_coord); \n"
        "    } \n"
        "} \n"
        " \n"
        "vec4 glup_draw_mesh(in vec4 color, in vec4 mesh_tex_coord) { \n"
        "    return mix( \n"
        "        GLUP.mesh_color, color, edge_factor(mesh_tex_coord) \n"
        "    ); \n"
        "} \n"
        " \n"
        "void main() { \n"
        " \n"
        "#ifdef GL_ES \n"
        "    if(glupIsEnabled(GLUP_CLIPPING) && (gl_ClipDistance[0] < 0.0)) { \n"
        "        discard; \n"
        "    } \n"
        "#endif \n"
        " \n"
        "    if(glupIsEnabled(GLUP_PICKING)) { \n"
        "        glup_FragColor = glup_picking(gl_PrimitiveID); \n"
        "        return; \n"
        "    } \n"
        " \n"
        "    vec4 result; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        result = FragmentIn.color; \n"
        "    } else { \n"
        "        result = gl_FrontFacing ? GLUP.front_color : GLUP.back_color; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        result = glup_texturing(result, FragmentIn.tex_coord); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        vec3 U = dFdx(FragmentIn.vertex_clip_space.xyz); \n"
        "        vec3 V = dFdy(FragmentIn.vertex_clip_space.xyz); \n"
        "        vec3 N = normalize(cross(U,V)); \n"
        "        result = glup_lighting(result, N); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_DRAW_MESH)) { \n"
        "        result = glup_draw_mesh(result, FragmentIn.mesh_tex_coord); \n"
        "    } \n"
        "    glup_FragColor = result; \n"
        "} \n"
        " \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/geometry_shader_preamble.h",
        "//import <GLUP/current_profile/geometry_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        " \n"
        " \n"
        "#if defined(GLUP_TESS_GATHER) \n"
        " \n"
        "in GTVertexData { \n"
        "    vec4 vertex_screen_space[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 vertex_clip_space[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 color[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 tex_coord[glup_nb_vertices_per_GL_v]; \n"
        "#ifndef GLUP_TESS_MULTI_VERTEX \n"
        "    bool discard_me; \n"
        "#endif \n"
        "} VertexIn[]; \n"
        " \n"
        "#elif defined(GLUP_VERTEX_GATHER) \n"
        " \n"
        "in GVertexData { \n"
        "    vec4 other_vertex_screen_space[glup_nb_vertices_per_GL_v-1]; \n"
        "    vec4 vertex_clip_space[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 color[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 tex_coord[glup_nb_vertices_per_GL_v]; \n"
        "} VertexIn[]; \n"
        " \n"
        "#else \n"
        " \n"
        "in VertexData { \n"
        "    vec4 vertex_clip_space; \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "} VertexIn[]; \n"
        " \n"
        "#endif \n"
        " \n"
        "out VertexData { \n"
        "    vec4 vertex_clip_space; \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "    vec4 mesh_tex_coord; \n"
        "} VertexOut; \n"
        " \n"
        "out float gl_ClipDistance[]; \n"
        " \n"
        "//****** Data abstraction ************** \n"
        " \n"
        "#if defined(GLUP_VERTEX_GATHER) || defined(GLUP_TESS_GATHER) \n"
        " \n"
        "#   if defined(GLUP_VERTEX_GATHER) \n"
        "vec4 vertex_screen_space_in(in int i) { \n"
        "    int i0 = i / glup_nb_vertices_per_GL_v; \n"
        "    int i1 = i % glup_nb_vertices_per_GL_v; \n"
        "    return (i1==0) ? gl_in[i0].gl_Position : \n"
        "        VertexIn[i0].other_vertex_screen_space[i1-1]; \n"
        "} \n"
        "#   else \n"
        "vec4 vertex_screen_space_in(in int i) { \n"
        "    int i0 = i / glup_nb_vertices_per_GL_v; \n"
        "    int i1 = i % glup_nb_vertices_per_GL_v; \n"
        "    return VertexIn[i0].vertex_screen_space[i1]; \n"
        "} \n"
        "#   endif \n"
        " \n"
        "vec4 vertex_clip_space_in(in int i) { \n"
        "    int i0 = i / glup_nb_vertices_per_GL_v; \n"
        "    int i1 = i % glup_nb_vertices_per_GL_v; \n"
        "    return VertexIn[i0].vertex_clip_space[i1]; \n"
        "} \n"
        " \n"
        "vec4 color_in(in int i) { \n"
        "    int i0 = i / glup_nb_vertices_per_GL_v; \n"
        "    int i1 = i % glup_nb_vertices_per_GL_v; \n"
        "    return VertexIn[i0].color[i1]; \n"
        "} \n"
        " \n"
        "vec4 tex_coord_in(in int i) { \n"
        "    int i0 = i / glup_nb_vertices_per_GL_v; \n"
        "    int i1 = i % glup_nb_vertices_per_GL_v; \n"
        "    return VertexIn[i0].tex_coord[i1]; \n"
        "} \n"
        " \n"
        "bool prim_is_discarded() { \n"
        "#if defined(GLUP_TESS_GATHER) && !defined(GLUP_TESS_MULTI_VERTEX) \n"
        "    return VertexIn[0].discard_me; \n"
        "#endif \n"
        "    return false; \n"
        "} \n"
        " \n"
        "#else \n"
        " \n"
        "vec4 vertex_screen_space_in(in int i) { \n"
        "    return gl_in[i].gl_Position; \n"
        "} \n"
        " \n"
        "vec4 vertex_clip_space_in(in int i) { \n"
        "    return VertexIn[i].vertex_clip_space; \n"
        "} \n"
        " \n"
        "vec4 color_in(in int i) { \n"
        "    return VertexIn[i].color; \n"
        "} \n"
        " \n"
        "vec4 tex_coord_in(in int i) { \n"
        "    return VertexIn[i].tex_coord; \n"
        "} \n"
        " \n"
        "bool prim_is_discarded() { \n"
        "    return false; \n"
        "} \n"
        " \n"
        "#endif \n"
        " \n"
        " \n"
        " \n"
        "// **** Utilities **************************** \n"
        " \n"
        "vec4 vertex_screen_space[glup_primitive_nb_vertices]; \n"
        " \n"
        "void get_vertices() { \n"
        "    for(int v=0; v<glup_primitive_nb_vertices; ++v) { \n"
        "        vertex_screen_space[v] = vertex_screen_space_in(v); \n"
        "    } \n"
        "    if(GLUP.cells_shrink != 0.0) { \n"
        "        vec4 g = vec4(0.0, 0.0, 0.0, 0.0); \n"
        "        for(int i=0; i<glup_primitive_nb_vertices; ++i) { \n"
        "            g += vertex_screen_space[i]; \n"
        "        } \n"
        "        g /= float(glup_primitive_nb_vertices); \n"
        "        float s = GLUP.cells_shrink; \n"
        "        for(int i=0; i<glup_primitive_nb_vertices; ++i) { \n"
        "            vertex_screen_space[i] = mix(vertex_screen_space[i], g, s); \n"
        "        } \n"
        "    } \n"
        "} \n"
        " \n"
        "float clip_distance(in vec4 V, in bool do_clip) { \n"
        "    return do_clip?dot(V,GLUP.clip_plane):1.0; \n"
        "} \n"
        " \n"
        "bool cell_is_clipped() { \n"
        "    if(prim_is_discarded()) { \n"
        "        return true; \n"
        "    } \n"
        "    if( \n"
        "        (glup_primitive_dimension != 3) || \n"
        "        !glupIsEnabled(GLUP_CLIPPING) || \n"
        "        GLUP.clipping_mode==GLUP_CLIP_STANDARD  || \n"
        "        GLUP.clipping_mode==GLUP_CLIP_SLICE_CELLS \n"
        "    ) { \n"
        "        return false; \n"
        "    } \n"
        "    int count = 0; \n"
        "    for(int i=0; i<glup_primitive_nb_vertices; ++i) { \n"
        "        count += int(clip_distance(vertex_clip_space_in(i),true) >= 0.0); \n"
        "    } \n"
        "    if(GLUP.clipping_mode==GLUP_CLIP_WHOLE_CELLS && count == 0) { \n"
        "        return true; \n"
        "    } \n"
        "    if( \n"
        "        GLUP.clipping_mode==GLUP_CLIP_STRADDLING_CELLS && \n"
        "        (count==0 || count==glup_primitive_nb_vertices) \n"
        "    ) { \n"
        "        return true; \n"
        "    } \n"
        "    return false; \n"
        "} \n"
        " \n"
        "void emit_vertex(in int i, in vec4 mesh_tex_coord, in bool do_clip) { \n"
        "    if(glupIsEnabled(GLUP_CLIPPING)) { \n"
        "        gl_ClipDistance[0] = clip_distance(vertex_clip_space_in(i),do_clip); \n"
        "    } \n"
        "    gl_Position = vertex_screen_space[i]; \n"
        "    // Forced, to make single vertex tess shader happy \n"
        "    // (either a bug in GLSL compiler or wrong order in \n"
        "    // my declarations) \n"
        "    if(true || glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        VertexOut.vertex_clip_space = vertex_clip_space_in(i); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        VertexOut.color = color_in(i); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        VertexOut.tex_coord = tex_coord_in(i); \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_DRAW_MESH)) { \n"
        "        VertexOut.mesh_tex_coord = mesh_tex_coord; \n"
        "    } \n"
        "    EmitVertex(); \n"
        "} \n"
        " \n"
        "void draw_triangle(in int i1, in int i2, in int i3, in bool do_clip) { \n"
        "    emit_vertex(i1, vec4(1.0, 0.0, 0.0, 0.0), do_clip); \n"
        "    emit_vertex(i2, vec4(0.0, 1.0, 0.0, 0.0), do_clip); \n"
        "    emit_vertex(i3, vec4(0.0, 0.0, 1.0, 0.0), do_clip); \n"
        "    EndPrimitive(); \n"
        "} \n"
        " \n"
        "void draw_quad(in int i1, in int i2, in int i3, in int i4, in bool do_clip) { \n"
        "    emit_vertex(i1, vec4(0.0, 1.0, 0.0, 1.0), do_clip); \n"
        "    emit_vertex(i2, vec4(1.0, 0.0, 0.0, 1.0), do_clip); \n"
        "    emit_vertex(i3, vec4(0.0, 1.0, 1.0, 0.0), do_clip); \n"
        "    emit_vertex(i4, vec4(1.0, 0.0, 1.0, 0.0), do_clip); \n"
        "    EndPrimitive(); \n"
        "} \n"
        " \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/tess_evaluation_shader.h",
        "//import <GLUP/current_profile/tess_evaluation_shader_preamble.h> \n"
        "//import <GLUPGLSL/state.h> \n"
        "//import <GLUP/stdglup.h> \n"
        "//import <GLUP/current_profile/toggles.h> \n"
        "//import <GLUP/current_profile/primitive.h> \n"
        " \n"
        "layout(isolines) in; \n"
        " \n"
        "in VertexData { \n"
        "    vec4 vertex_clip_space; \n"
        "    vec4 color; \n"
        "    vec4 tex_coord; \n"
        "} VertexIn[]; \n"
        " \n"
        "out GTVertexData { \n"
        "    vec4 vertex_screen_space[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 vertex_clip_space[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 color[glup_nb_vertices_per_GL_v]; \n"
        "    vec4 tex_coord[glup_nb_vertices_per_GL_v]; \n"
        "#ifndef GLUP_TESS_MULTI_VERTEX \n"
        "    bool discard_me; \n"
        "#endif \n"
        "} VertexOut; \n"
        " \n"
        "#ifdef GLUP_TESS_MULTI_VERTEX \n"
        " \n"
        "void main() { \n"
        "    int i0 = int(gl_TessCoord.x + 0.5); \n"
        "    for(int i1=0; i1<glup_nb_vertices_per_GL_v; ++i1) { \n"
        "        int i = i0*glup_nb_vertices_per_GL_v + i1; \n"
        "        VertexOut.vertex_screen_space[i1] = gl_in[i].gl_Position; \n"
        "        if(glupIsEnabled(GLUP_CLIPPING) || glupIsEnabled(GLUP_LIGHTING)) { \n"
        "            VertexOut.vertex_clip_space[i1] = VertexIn[i].vertex_clip_space; \n"
        "        } \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        for(int i1=0; i1<glup_nb_vertices_per_GL_v; ++i1) { \n"
        "            int i = i0*glup_nb_vertices_per_GL_v + i1; \n"
        "            VertexOut.color[i1] = VertexIn[i].color; \n"
        "        } \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        for(int i1=0; i1<glup_nb_vertices_per_GL_v; ++i1) { \n"
        "            int i = i0*glup_nb_vertices_per_GL_v + i1; \n"
        "            VertexOut.tex_coord[i1] = VertexIn[i].tex_coord; \n"
        "        } \n"
        "    } \n"
        "} \n"
        "#else \n"
        " \n"
        "void main() { \n"
        "    VertexOut.discard_me = (gl_TessCoord.x > 0.5); \n"
        "    if(VertexOut.discard_me) { \n"
        "        return; \n"
        "    } \n"
        "    for(int i=0; i<glup_primitive_nb_vertices; ++i) { \n"
        "        VertexOut.vertex_screen_space[i] = gl_in[i].gl_Position; \n"
        "        if(glupIsEnabled(GLUP_CLIPPING) || glupIsEnabled(GLUP_LIGHTING)) { \n"
        "            VertexOut.vertex_clip_space[i] = VertexIn[i].vertex_clip_space; \n"
        "        } \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        for(int i=0; i<glup_primitive_nb_vertices; ++i) { \n"
        "            VertexOut.color[i] = VertexIn[i].color; \n"
        "        } \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        for(int i=0; i<glup_primitive_nb_vertices; ++i) { \n"
        "            VertexOut.tex_coord[i] = VertexIn[i].tex_coord; \n"
        "        } \n"
        "    } \n"
        "} \n"
        " \n"
        "#endif \n"
        " \n"
        " \n"
     );

     GEO::GLSL::register_GLSL_include_file("GLUPGLSL/marching_cells.h",
        "//import <GLUP/current_profile/marching_cells.h> \n"
        " \n"
        "int compute_config() { \n"
        "    int result = 0; \n"
        "    for(int v=0; v<cell_nb_vertices; ++v) { \n"
        "        if(dot(vertex_clip_space_in(v),GLUP.clip_plane) > 0.0) { \n"
        "            result = result | (1 << v); \n"
        "        } \n"
        "    } \n"
        "    return result; \n"
        "} \n"
        " \n"
        "void emit_isect_vertex(in int i, in vec4 mesh_tex_coord) { \n"
        "    gl_ClipDistance[0] = 1.0; \n"
        "    gl_Position = isect_point_screen_space[i]; \n"
        "    if(glupIsEnabled(GLUP_VERTEX_COLORS)) { \n"
        "        VertexOut.color = isect_color[i]; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_TEXTURING)) { \n"
        "        VertexOut.tex_coord = isect_tex_coord[i]; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_DRAW_MESH)) { \n"
        "        VertexOut.mesh_tex_coord = mesh_tex_coord; \n"
        "    } \n"
        "    if(glupIsEnabled(GLUP_LIGHTING)) { \n"
        "        VertexOut.vertex_clip_space = isect_point_clip_space[i]; \n"
        "    } \n"
        "    EmitVertex(); \n"
        "} \n"
        " \n"
        "void isect_triangle( \n"
        "    in int i, in vec4 mtexi, \n"
        "    in int j, in vec4 mtexj, \n"
        "    in int k, in vec4 mtexk \n"
        ") { \n"
        "    emit_isect_vertex(i,mtexi); \n"
        "    emit_isect_vertex(j,mtexj); \n"
        "    emit_isect_vertex(k,mtexk); \n"
        "} \n"
        " \n"
        "void draw_marching_cell() { \n"
        "    int config = compute_config(); \n"
        "    if(config_size(config) == 0) { \n"
        "        return; \n"
        "    } \n"
        "    compute_intersections(); \n"
        "    int size = config_size(config); \n"
        "    if(glupIsEnabled(GLUP_DRAW_MESH)) { \n"
        "        // Single triangle: mesh tex coords are standard tri mesh tex coord. \n"
        "        if(size == 3) { \n"
        "            isect_triangle( \n"
        "                config_edge(config,0), vec4(1.0, 0.0, 0.0, 0.0), \n"
        "                config_edge(config,1), vec4(0.0, 1.0, 0.0, 0.0), \n"
        "                config_edge(config,2), vec4(0.0, 0.0, 1.0, 0.0) \n"
        "            ); \n"
        "        } else { \n"
        "            // First triangle: draw mesh only on first wedge \n"
        "            // (let's pretend it is a wedge of a quad) \n"
        "            isect_triangle( \n"
        "                config_edge(config,0), vec4(0.0, 1.0, 0.0, 1.0), \n"
        "                config_edge(config,1), vec4(1.0, 0.0, 0.0, 1.0), \n"
        "                config_edge(config,2), vec4(1.0, 0.0, 1.0, 0.0) \n"
        "            ); \n"
        "            // Middle triangles: draw mesh only on [i,i+1] \n"
        "            // (let's pretend that vertex i is the quad center) \n"
        "            for(int i=2; i+2<size; ++i) { \n"
        "                isect_triangle( \n"
        "                    config_edge(config,0), vec4(0.5, 0.5, 0.5, 0.5), \n"
        "                    config_edge(config,i), vec4(0.0, 1.0, 0.0, 1.0), \n"
        "                    config_edge(config,i+1), vec4(1.0, 0.0, 0.0, 1.0) \n"
        "                ); \n"
        "            } \n"
        "            // Last triangle: draw mesh only on last wedge \n"
        "            // (let's pretend it is a wedge of a quad) \n"
        "            isect_triangle( \n"
        "                config_edge(config,0),      vec4(0.0, 1.0, 0.0, 1.0), \n"
        "                config_edge(config,size-2), vec4(1.0, 0.0, 1.0, 0.0), \n"
        "                config_edge(config,size-1), vec4(1.0, 0.0, 0.0, 1.0) \n"
        "            ); \n"
        "        } \n"
        "    } else { \n"
        "        for(int i=1; i+1<size; ++i) { \n"
        "            isect_triangle( \n"
        "                config_edge(config,0),   vec4(0.0, 0.0, 0.0, 0.0), \n"
        "                config_edge(config,i),   vec4(0.0, 0.0, 0.0, 0.0), \n"
        "                config_edge(config,i+1), vec4(0.0, 0.0, 0.0, 0.0) \n"
        "            ); \n"
        "        } \n"
        "    } \n"
        "} \n"
        " \n"
        "bool compute_clip_coords() { \n"
        "    return ( \n"
        "        glupIsEnabled(GLUP_CLIPPING) && \n"
        "        GLUP.clipping_mode==GLUP_CLIP_STANDARD \n"
        "    ); \n"
        "} \n"
        " \n"
        "bool draw_clipped_cell() { \n"
        "    if(cell_is_clipped()) { \n"
        "        return true; \n"
        "    } \n"
        "    gl_PrimitiveID = gl_PrimitiveIDIn; \n"
        "    get_vertices(); \n"
        "    if( \n"
        "        glupIsEnabled(GLUP_CLIPPING) && \n"
        "        GLUP.clipping_mode == GLUP_CLIP_SLICE_CELLS \n"
        "    ) { \n"
        "        draw_marching_cell(); \n"
        "        return true; \n"
        "    } \n"
        "    return false; \n"
        "} \n"
        " \n"
     );

   }
}
