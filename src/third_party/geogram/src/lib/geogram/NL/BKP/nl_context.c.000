/*
 *  Copyright (c) 2004-2010, Bruno Levy
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *  this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation
 *  and/or other materials provided with the distribution.
 *  * Neither the name of the ALICE Project-Team nor the names of its
 *  contributors may be used to endorse or promote products derived from this
 *  software without specific prior written permission.
 * 
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *
 *  If you modify this software, you should include a notice giving the
 *  name of the person performing the modification, the date of modification,
 *  and the reason for such modification.
 *
 *  Contact: Bruno Levy
 *
 *     levy@loria.fr
 *
 *     ALICE Project
 *     LORIA, INRIA Lorraine, 
 *     Campus Scientifique, BP 239
 *     54506 VANDOEUVRE LES NANCY CEDEX 
 *     FRANCE
 *
 */

#include "nl_context.h"
#include "nl_iterative_solvers.h"
#include "nl_preconditioners.h"
#include "nl_superlu.h"
#include "nl_cholmod.h"
#include "nl_cnc_gpu_cuda.h"
#include "nl_matrix.h"

NLContextStruct* nlCurrentContext = NULL;

/**
 * \brief Implements the default matrix vector product.
 * \details Uses the sparse matrix stored in the current
 *  context.
 * \param[in] x the constant right hand side (size = nlCurrentContext->m)
 * \param[out] y the result (size = nlCurrentContext->n)
 */
static void nlMatrixVectorProd_default(const NLdouble* x, NLdouble* y) {
    NLMatrix M = nlCurrentContext->M;
    nlMultMatrixVector(M, x, y);
    if(M->type == NL_MATRIX_SPARSE_DYNAMIC) {
	nlCurrentContext->flops +=
	    (NLulong)(nlSparseMatrixNNZ((NLSparseMatrix*)M)*2);
    } else if(M->type == NL_MATRIX_CRS) {
	nlCurrentContext->flops +=
	    (NLulong)(nlCRSMatrixNNZ((NLCRSMatrix*)M)*2);
    }
}

/**
 * \brief Implements the default preconditioner matrix vector product.
 * \details Uses the preconditioner matrix stored in the current
 *  context.
 * \param[in] x the constant right hand side (size = nlCurrentContext->m)
 * \param[out] y the result (size = nlCurrentContext->n)
 */
static void nlPreconditionerVectorProd_default(const NLdouble* x, NLdouble* y) {
    NLMatrix P = nlCurrentContext->P;
    nlMultMatrixVector(P, x, y);
}

NLContext nlNewContext() {
    NLContextStruct* result     = NL_NEW(NLContextStruct);
    result->state               = NL_STATE_INITIAL;
    result->solver              = NL_SOLVER_DEFAULT;
    result->max_iterations      = 100;
    result->threshold           = 1e-6;
    result->omega               = 1.5;
    result->row_scaling         = 1.0;
    result->inner_iterations    = 5;
    result->matrix_vector_prod  = nlMatrixVectorProd_default;
    result->solver_func         = nlDefaultSolver;
    result->progress_func       = NULL;
    result->verbose             = NL_FALSE;
    result->nb_systems          = 1;
    nlMakeCurrent(result);
    return result;
}

void nlDeleteContext(NLContext context_in) {
    NLContextStruct* context = (NLContextStruct*)(context_in);
    if(nlCurrentContext == context) {
        nlCurrentContext = NULL;
    }

    nlDeleteMatrix(context->M);
    context->M = NULL;

    nlDeleteMatrix(context->P);
    context->P = NULL;
    
    if(context->alloc_af) {
        nlRowColumnDestroy(&context->af);
    }
    if(context->alloc_al) {
        nlRowColumnDestroy(&context->al);
    }
    if(context->alloc_xl) {
        nlRowColumnDestroy(&context->xl);
    }
    if(context->alloc_variable) {
	NL_DELETE_ARRAY(context->variable_value);
	NL_DELETE_ARRAY(context->variable_is_locked);
	NL_DELETE_ARRAY(context->variable_index);
    }
    if(context->alloc_x) {
        NL_DELETE_ARRAY(context->x);
    }
    if(context->alloc_b) {
        NL_DELETE_ARRAY(context->b);
    }
    if(context->alloc_right_hand_side) {
	NL_DELETE_ARRAY(context->right_hand_side);
    }
    
#ifdef NL_PARANOID
    NL_CLEAR(NLContextStruct, context);
#endif
    NL_DELETE(context);
}

void nlMakeCurrent(NLContext context) {
    nlCurrentContext = (NLContextStruct*)(context);
}

NLContext nlGetCurrent() {
    return nlCurrentContext;
}

/************************************************************************/
/* Finite state automaton   */

void nlCheckState(NLenum state) {
    nl_assert(nlCurrentContext->state == state);
}

void nlTransition(NLenum from_state, NLenum to_state) {
    nlCheckState(from_state);
    nlCurrentContext->state = to_state;
}

/************************************************************************/
/* Preconditioner setup and default solver */

static void nlSetupPreconditioner() {
    /* Check compatibility between solver and preconditioner */
    if(
        nlCurrentContext->solver == NL_BICGSTAB && 
        nlCurrentContext->preconditioner == NL_PRECOND_SSOR
    ) {
        nlWarning(
            "nlSolve", 
            "cannot use SSOR preconditioner with non-symmetric matrix, "
	    "switching to Jacobi"
        );
        nlCurrentContext->preconditioner = NL_PRECOND_JACOBI;        
    }
    if(
        nlCurrentContext->solver == NL_GMRES && 
        nlCurrentContext->preconditioner != NL_PRECOND_NONE
    ) {
        nlWarning("nlSolve", "Preconditioner not implemented yet for GMRES");
        nlCurrentContext->preconditioner = NL_PRECOND_NONE;        
    }
    if(
        nlCurrentContext->solver == NL_SUPERLU_EXT && 
        nlCurrentContext->preconditioner != NL_PRECOND_NONE
    ) {
        nlWarning("nlSolve", "Preconditioner not implemented yet for SUPERLU");
        nlCurrentContext->preconditioner = NL_PRECOND_NONE;        
    }
    if(
        nlCurrentContext->solver == NL_CHOLMOD_EXT && 
        nlCurrentContext->preconditioner != NL_PRECOND_NONE
    ) {
        nlWarning("nlSolve", "Preconditioner not implemented yet for CHOLMOD");
        nlCurrentContext->preconditioner = NL_PRECOND_NONE;        
    }
    if(
        nlCurrentContext->solver == NL_PERM_SUPERLU_EXT && 
        nlCurrentContext->preconditioner != NL_PRECOND_NONE
    ) {
        nlWarning(
	    "nlSolve", "Preconditioner not implemented yet for PERMSUPERLU"
	);
        nlCurrentContext->preconditioner = NL_PRECOND_NONE;        
    }
    if(
        nlCurrentContext->solver == NL_SYMMETRIC_SUPERLU_EXT && 
        nlCurrentContext->preconditioner != NL_PRECOND_NONE
    ) {
        nlWarning(
	    "nlSolve", "Preconditioner not implemented yet for PERMSUPERLU"
	);
        nlCurrentContext->preconditioner = NL_PRECOND_NONE;        
    }

    switch(nlCurrentContext->preconditioner) {
    case NL_PRECOND_NONE:
        nlCurrentContext->precond_vector_prod = NULL;
        break;
    case NL_PRECOND_JACOBI:
	nlCurrentContext->P = nlNewJacobiPreconditioner(nlCurrentContext->M);
	nlCurrentContext->precond_vector_prod =
	    nlPreconditionerVectorProd_default;
        break;
    case NL_PRECOND_SSOR:
	nlCurrentContext->P = nlNewSSORPreconditioner(
	    nlCurrentContext->M,nlCurrentContext->omega
	);	
	nlCurrentContext->precond_vector_prod =
	    nlPreconditionerVectorProd_default;	
        break;
    case NL_PRECOND_USER:
        break;
    default:
        nl_assert_not_reached;
    }

    if(nlCurrentContext->preconditioner != NL_PRECOND_SSOR) {
        if(getenv("NL_LOW_MEM") == NULL) {
            nlMatrixCompress(&nlCurrentContext->M);
        }
    }
}

static NLboolean nlSolveDirect() {
    NLMatrix F = nlMatrixFactorize(
	nlCurrentContext->M, nlCurrentContext->solver
    );
    if(F == NULL) {
	return NL_FALSE;
    }
    nlMultMatrixVector(F, nlCurrentContext->b, nlCurrentContext->x);
    nlDeleteMatrix(F);
    return NL_TRUE;
}

NLboolean nlDefaultSolver() {
    NLboolean result = NL_TRUE;
    nlSetupPreconditioner();
    switch(nlCurrentContext->solver) {
    case NL_CG: {
        if(nlCurrentContext->preconditioner == NL_PRECOND_NONE) {
            nlCurrentContext->used_iterations = nlSolve_CG();
        } else {
            nlCurrentContext->used_iterations = nlSolve_CG_precond();
        }
    } break;
    case NL_BICGSTAB: {
        if(nlCurrentContext->preconditioner == NL_PRECOND_NONE) {
            nlCurrentContext->used_iterations = nlSolve_BICGSTAB();
        } else {
            nlCurrentContext->used_iterations = nlSolve_BICGSTAB_precond();
        }
    } break;
    case NL_GMRES: {
        nlCurrentContext->used_iterations = nlSolve_GMRES();
    } break;
    case NL_CNC_FLOAT_CRS_EXT:
    case NL_CNC_DOUBLE_CRS_EXT:
    case NL_CNC_FLOAT_BCRS2_EXT:
    case NL_CNC_DOUBLE_BCRS2_EXT:
    case NL_CNC_FLOAT_ELL_EXT:
    case NL_CNC_DOUBLE_ELL_EXT:
    case NL_CNC_FLOAT_HYB_EXT:
    case NL_CNC_DOUBLE_HYB_EXT: {
        nlCurrentContext->used_iterations = nlSolve_CNC();
    } break;
    case NL_SUPERLU_EXT: 
    case NL_PERM_SUPERLU_EXT: 
    case NL_SYMMETRIC_SUPERLU_EXT: 
    case NL_CHOLMOD_EXT: {
        result = nlSolveDirect();
    } break;
    default:
        nl_assert_not_reached;
    }
    return result;
}
